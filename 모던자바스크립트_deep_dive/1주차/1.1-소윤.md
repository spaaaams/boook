### 변수 
#### 🤨 1. 변수란 무엇이고 왜 필요할까?
`10 + 20` 해당 식을 보았을때 우리는 10이라는 숫자 + 라는 기호 그리고 20이라는 숫자 이의 결과 값인 30 이렇게 기억하고 있을 것이다. <br> 
컴퓨터는 사람과 유사해서 10, 20, + 라는 기호의 의미를 알고 있어야 하며 10 + 20 이라는 식(표현식)의 의미도 해석(파싱)할 줄 알아야 한다.

사람은 단순한 사칙연산 같은 경우 두뇌를 사용하여 값을 도출할 수 있지만 컴퓨터는 __연산__ 과 __기억__ 을 수행하는 부품이 나뉘어져 있다.

컴퓨터는 CPU를 사용하여 연산하고, 메모리를 사용하여 데이터를 기억한다.

메모리 : 데이터를 저장할 수 있는 메모리 셀의 집합체 <br>
메모리 셀 하나의 크기 : 1바이트 <br>
컴퓨터는 메모리 셀의 크기 즉, 1바이트 단위로 데이터를 저장하거나 읽는다.
<br>
(사진)

각 메모리 셀은 고유 메모리 주소를 갖는다. (메모리 주소 == 메모리 공간의 위치) <br>

위의 예제에서 숫자 10과 20은 메모리 주소에 저장되고 CPU는 이 값을 읽어 연산을 실행한다. 연산결과로 도출된 30이라는 값도 메모리 상의 임의 위치에 저장된다.

이렇게 성공적으로 끝마친것같지만 CPU가 연산한 30이라는 값을 우리는 재사용할 수 없다. <br>
30이라는 값이 저장되고 있는 메모리 주소에 직접 접근하는 것 외에는 방법이 존재하지 않는다. <br>

프로그래밍 언어는 기억하고싶은 값을 메모리에 저장하고, 이 값을 읽어 재사용하기 위하여 변수라는 메커니즘을 제공한다.

즉 다시한번 변수를 말하자면<br>
하나의 값을 저장하기 위해 확보된 메모리 공간 자체 혹은 메모리 공간을 식별하기 위해 붙인 이름을 의미한다. <br>
_(값의 위치를 가리키는 상징적인 이름)_<br>
즉, 개발자는 직접 메모리 주소를 참조할 필요 없이 변수를 통해 안전하게 값에 접근할 수 있는 것이다. 

```
var result = 10 + 20;
```

10 + 20은 연산을 통해 새로운 값 30을 생성한다.<br>
↓<br>
이렇게 생성된 30 이라는 값은 메모리 공간에 저장된다.
↓<br>
이때 메모리 공간에 저장된 값 30을 다시 읽어 재사용할 수 있도록 값이 저장된 메모리 공간에 상징적으로 이름을 붙인것이 __변수__ 이다.


__용어 정리__
- 변수이름(변수명) : 메모리 공간에 저장된 값을 식별할 수 있는 고유 이름
- 변수 값 : 변수에 저장된 값


#### 🧮 2. 식별자
=> 어떤 값을 구별해서 식별할 수 있는 고유한 이름 <br>
_변수의 이름을 __식별자__ 라고도 한다._ <br>

값은 메모리 공간에 저장되어있기에 식별자는 메모리 공간에 저장되어있는 어떠한 값을 구별해서 식별해야한다.

즉 그림 4-3에서 식별자 result는 값 30을 식별할 수 있다. <br>
그러나 '30'이라는 값을 가지고 오기 위하여 __메모리 주소__ 를 기억해야한다. <br>

식별자는 값이 저장되어있는 메모리 주소와 매핑 관계를 맺으며 이 매핑 정보도 메모리에 저장 되어야 한다.

__즉, 식별자는 값 이 아닌 메모리 주소를 기억하고 있다.(식별자는 메모리 주소에 붙인 이름)__
<br>

그러나, 식별자 라는 이름을 변수에 국한해서 사용하지않고, __변수 , 함수, 클래스__ 등의 이름 전부 식별자가 될 수 있다. <br>
그이유는, 식별자는 메모리 주소를 기억하기에 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 식별자 하고 부르기 때문이다.<br>

#### 3. 변수 선언
=> 변수를 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결하여 값을 저장할 수 있게 준비하는 것이다.
<br>
_메모리 공간이 해제되기 이전까지 안전하게 사용할 수 있다._

⭐️ 변수를 사용하기 위해서? <br>
- var
- let 
- const <br>

키워드를 사용해야한다.

ES6가 나오기 이전에는 `var` 만 사용할 수 있었다.<br>
그러나, 이는 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원한다는 단점이 있어 이로 인해 의도하지 않았지만 선언한 변수가 전역 변수로 선언이 되는 문제가 발생하기도 했다.

__예시__

```
var score; //변수 선언
```
위의 코드는 `score` 라는 변수 이름을 등록하고, 값을 저장할 메모리 공간을 확보한다. 

(사진)

우리는 `score` 이라는 변수를 선언한 이후에 어떠한 값도 할당하지 않았기 때문에 비어있다고 생각할 수 있지만, JS 엔진에 의하여 undefined라는 값이 암묵적으로 할당 되어 __초기화__ 된다.

_여기서 초기화란 변수가 선언 된 이후 최초로 값을 할당하는 것을 말함_

초기화 단계를 거치지 않으면 이전 다른 어플리케이션에서 사용했던 값이 남아 있을 수 있다. <br>
그러나, var은 선언과 동시에 초기화가 되기 때문에 이러한 위험에서는 안전하다.

JS엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다. <br>
- 선언 단계 : 변수 이름을 등록하여 JS엔진에게 해당 변수가 있음을 알린다.
- 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고, 암묵적 undefined를 할당하여 초기화 한다.

🤔 이러한 변수 이름은 어디에 등록 되는 것일까? <br>
변수 이름 및 식별자는 __실행 컨텍스트__ 에 등록된다.<br>
실행 컨텍스트는 JS엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고, 코드의 실행 결과를 관리하는 영역이다.<br>
변수의 이름과 / 값은 실행 컨텍스트 내에서 키와 값의 형식인 객체로 등록되어 관리된다.

변수의 선언은 당연한 것이다.<br>
변수를 선언하지 않고, 해당 변수를 사용하려고한다면 'ReferenceError(참조에러)' 가 발생한다.

#### ♻️ 4. 변수 선언의 실행 시점과 변수 호이스팅
```
console.log(score); //undefined

var score; //변수 선언문
```
상식적으로 언급되지 않은 score을 사용하고 있으니 위에서 말했던 ReferenceError가 날 것이라고 생각하지만, Javascript에서는 조금 다르다.<br>

그 이유는<br>
변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.<br>

__⚙️ JS엔진 특징__<br>
소스코드를 한 줄씩 순차적으로 실행하지 않고, 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다.<br>
이때, 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행한다. 이후, 변수 선언을 포함한 모든 선언문을제외한 소스코드를 한 줄 씩 실행한다.

이처럼 __변수 선언문이 코드의 맨위로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유 특징을 변수 호이스팅 이라고 한다.__



