## 19.14 프로퍼티 열거

### 19.14.1 for...in 문

객체의 모든 프로퍼티를 순회하며 열거<sup>enumeration</sup>하려면 `for...in` 문을 사용한다.

> 구문:
> <br />
> for (변수 in 객체) {...}

```javascript
const person = {
  name: "Yeo",
  address: "Seongnam",
};

// for...in 문의 변수 key에 person 객체의 프로퍼티 키가 할당된다.
for (const key in person) {
  console.log(`${key}: ${person[key]}`);
}

// 출력 결과:
// name: Yeo
// address: Seongnam
```

- `for...in` 문은 객체의 프로퍼티 개수만큼 순회하며, 변수에 각 프로퍼티 키를 할당한다.
- 예제에서 `person` 객체에는 2개의 프로퍼티가 있으므로, 두 번 순회하여 각각 `name`과 `address` 키를 `key` 변수에 할당하고, 해당 값을 출력한다.

`for...in` 문은 상속받은 프로토타입의 프로퍼티까지 열거한다.
<br />
하지만 `Object.prototype`의 `toString`과 같은 프로퍼티는 열거되지 않는다.

```javascript
const person = {
  name: "Yeo",
  address: "Seongnam",
};

// in 연산자는 객체가 상속받은 모든 프로토타입의 프로퍼티를 한다.
console.log("toString" in person); // true

// for...in 문도 객체가 상속받은 모든 프로토타입의 프로퍼티를 열거한다.
// 하지만 toString과 같은 Object.prototype의 프로퍼티는 열거되지 않는다.
for (const key in person) {
  console.log(`${key}: ${person[key]}`);
}

// 출력 결과:
// name: Yeo
// address: Seongnam
```

이는 `toString` 메서드가 열거할 수 없도록 정의되어 있기 때문이다.
<br />
`Object.prototype.toString`의 프로퍼티 어트리뷰트 `[[Enumerable]]`의 값이 `false`이기 때문에 열거되지 않는다.

```javascript
// Object.getOwnPropertyDescriptor 메서드는 프로퍼티 디스크립터 객체를 반환한다.
console.log(Object.getOwnPropertyDescriptor(Object.prototype, "toString"));

// 출력 결과:
// {value: ƒ, writable: true, enumerable: false, configurable: true}
```

따라서 `for...in` 문은 객체의 프로토타입 체인 상에 존재하는 프로퍼티 중 `[[Enumerable]]`의 값이 `true`인 프로퍼티만 순회한다.

<br />

`for...in` 문은 상속된 프로퍼티도 순회하므로, 객체 자신의 프로퍼티만 열거하려면 `Object.prototype.hasOwnProperty`를 사용해야 한다.

```javascript
const person = {
  name: "Yeo",
  address: "Seongnam",
  __proto__: { age: 27 },
};

for (const key in person) {
  // 객체 자신의 프로퍼티인지 확인한다.
  if (!person.hasOwnProperty(key)) continue;
  console.log(`${key}: ${person[key]}`);
}

// 출력 결과:
// name: Yeo
// address: Seongnam
```

<br />

`for...in` 문은 프로퍼티를 열거할 때 순서를 보장하지 않으므로 주의해야 한다.
<br />
하지만 대부분의 모던 브라우저는 순서를 보장하며, 숫자 형태의 키는 정렬한다.

```javascript
const obj = {
  2: 2,
  3: 3,
  1: 1,
  b: "b",
  a: "a",
};

for (const key in obj) {
  if (!obj.hasOwnProperty(key)) continue;
  console.log(`${key}: ${obj[key]}`);
}

// 출력 결과:
// 1: 1
// 2: 2
// 3: 3
// b: b
// a: a
```

<br />

배열에는 `for...in` 문을 사용하지 않고, 일반적인 `for` 문, `for...of` 문, 또는 `Array.prototype.forEach` 메서드를 사용하는 것이 좋다.
<br />
배열도 객체이므로 프로퍼티와 상속받은 프로퍼티가 포함될 수 있기 때문이다.

```javascript
const arr = [1, 2, 3];
arr.x = 10; // 배열도 객체이므로 프로퍼티를 가질 수 있다.

for (const i in arr) {
  console.log(arr[i]); // 1 2 3 10 (프로퍼티 x도 출력됨)
}

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]); // 1 2 3
}

// forEach 메서드는 요소가 아닌 프로퍼티는 제외한다.
arr.forEach((v) => console.log(v)); // 1 2 3

// for...of는 변수 선언문에서 선언한 변수에 키가 아닌 값을 할당한다.
for (const value of arr) {
  console.log(value); // 1 2 3
}
```

---

### 19.14.2 Object.keys/values/entries 메서드

`for...in` 문은 객체 자신의 고유 프로퍼티뿐만 아니라 상속받은 프로퍼티까지 열거한다.
<br />
따라서, 객체 자신의 프로퍼티만을 확인하고자 할 때는 `Object.prototype.hasOwnProperty` 메서드를 사용하여 추가 처리를 해야 한다.

객체 자신의 고유 프로퍼티만 열거하기 위해서는 `for...in` 문보다 `Object.keys`, `Object.values`, `Object.entries` 메서드를 사용하는 것이 좋다.

- `Object.keys` 메서드: 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환

```javascript
const person = {
  name: "Yeo",
  address: "Seongnam",
  __proto__: { age: 27 },
};

console.log(Object.keys(person));

// 출력 결과: ["name", "address"]
```

- `Object.values` 메서드 (ES8 도입): 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환

```javascript
console.log(Object.values(person));

// 출력 결과: ['Yeo', 'Seongnam']
```

- `Object.entries` 메서드 (ES8 도입): 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍을 배열에 담아 반환

```javascript
console.log(Object.entries(person));

// 출력 결과: [["name", "Yeo"], ["address", "Seongnam"]]
```
