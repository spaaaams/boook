# let, const 키워드와 블록 레벨 스코프

## 1. var 키워드로 선언한 변수의 문제

- ES5 까지 변수를 선언할 수 있는 유일한 방법인 var에는 다음과 같은 특징이 있다.
  - 변수 중복 선언 허용
  - 함수 레벨 스코프
  - 변수 호이스팅

### 변수 중복 선언 허용

- var 키워드로 선언한 변수는 중복 선언이 가능하다.

```javascript
var x = 1;
var y = 1;

var x = 100;
var y;

console.log(x, y); // 100, 1
```

- 위 예제에서 var 키워드로 선언한 x 변수와 y 변수는 중복 선언되었다.
- 이처럼 var 키워드로 선언한 변수를 중복 선언하면 초기화문 유무에 따라 다르게 동작한다.
- 초기화문이 있으면 var 키워드가 없는 것처럼 동작하고 초기화문이 없으면 무시된다. (에러는 발생하지 않는다.)
- 이 경우 이미 변수가 선언되어 있는 것을 모르고 변수를 중복 선언할 수 있기 때문에 문제가 야기될 수 있다.

### 함수 레벨 스코프

- var 키워드로 선언한 변수는 함수의 코드 블록만을 지역 스코프로 인정한다.
- 따라서 `함수 외부에서 var 키워드로 선언한 변수는` 코드 블록 내에서 선언했더라도 `전역 변수` 가 된다.
- 함수 레벨 스코프트는 전역 변수를 남발할 가능성이 높기 때문에 의도치 않게 전역 변수가 중복 선언되는 경우가 발생한다.

### 변수 호이스팅

- var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.
- 즉, var 키워드로 선언한 변수는 선언 이전에 참조가 가능하다.
- 단, 할당문 이전에 변수를 참조하면 언제나 `undefined`를 반환한다.

## 2. let 키워드

- 자 이제 ES6 이후 등장한 let에 대해서 var와 비교해보며 살펴보자.

### 변수 중복 선언 금지

- let 키워드로 이름이 같은 변수를 중복 선언하면 SyntaxError가 발생한다.

### 블록 레벨 스코프

- let 키워드로 선언한 변수는 var와는 다르게 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.
- 따라서 코드 블록 내에서 선언된 변수는 모두 지역 변수다.
- 같은 이름을 가진 변수더라도 코드 블록이 다르다면 별개의 변수이다.
- 함수 또한 코드 블록이므로 스코프를 만든다. 이때 함수 내의 코드 블록은 함수 레벨 스코프에 중첩된다.

### 변수 호이스팅

- var 키워드와는 다르게 let으로 선언한 변수는 호이스팅이 발생하지 않는 것처럼 동작한다.

```javascript
console.log(foo); // ReferenceError: foo is not defined
let foo;
```

- 이처럼 let 키워드로 선언한 변수를 변수 선언문 이전에 참조하면 참조 에러가 발생한다.
- var로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 "선언"과 "초기화" 단계가 한번에 진행된다.
- 즉, 선언 단계에서 스코프에 변수 식별자를 등록해 자바스크립트 엔진에 변수의 존재를 알리고
  즉시 초기화 단계에서 undefined로 변수를 초기화한다.
- 이로 인해 변수 선언 이전에 접근하더라도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는것이다.
- **let은 "선언"과 "초기화" 단계가 분리되어 진행된다.**
- 이 때문에 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러가 발생한다.
- let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점까지 변수를 참조할 수 없다.
- 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대** (TDZ) 라고 부른다.
- 결국 let 키워드로 선언한 변수는 호이스팅이 발생하지 않는 것처럼 보인다. (실제로 일어나지 않는것은 아니다.)

### 전역 객체와 let

- var 키워드로 선언한 전역 변수와 전역 함수, 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체의 window의 프로퍼티가 된다.
- 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.

```javascript
// 이 예제는 브라우저 환경에서 실행해야 한다

// 전역 변수
var x = 1;
// 암묵적 전역
y = 2；
// 전역 함수
function foo() {}

// var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티다
console.log(window.x); // 1

// 전역 객체 window의 프로퍼티는 전역 변수처럼 사용할 수 있다
console.log(x); // 1

// 암묵적 전역은 전역 객체 window의 프로퍼티다
console.log(window.y); // 2
console.log(y); // 2

// 함수 선언문으로 정의한 전역 함수는 전역 객체 window의 프로퍼티다
console.log(window.foo); // f foo() {}

// 전역 객체 window의 프로퍼티는 전역 변수처럼 사용할 수 있다
console.log(foo); // f foo() {}
```

- let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다
- 즉, window.foo와 같이 접근할 수 없다
- let 전역 변수는 보이지 않는 개념적인 블록
