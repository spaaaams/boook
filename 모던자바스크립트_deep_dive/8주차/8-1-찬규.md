## 17.2.5 constructor와 non-constructor의 구분

자바스크립트 엔진은 함수 정의 방식을 평가해 함수 객체를 `constructor`와 `non-constructor`로 구분한다.

- `constructor`: 함수 선언문, 함수 표현식, 클래스
- `non-constructor`: ES6 메서드 축약 표현, 화살표 함수

```javascript
// constructor 예시
function foo() {}
const bar = function () {};

// 프로퍼티에 할당된 함수도 일반 함수로 정의된 것이면 constructor다.
const baz = { x: function () {} };

// constructor 함수들은 new로 호출할 수 있다.
new foo(); // foo {}
new bar(); // bar {}
new baz.x(); // x {}

// non-constructor 예시
const arrow = () => {};
new arrow(); // TypeError: arrow is not a constructor

// ES6 메서드 축약 표현만 메서드로 인정된다.
const obj = { x() {} };
new obj.x(); // TypeError: obj.x is not a constructor
```

프로퍼티 값으로 사용된 함수는 보통 메서드로 불리지만, ECMAScript 사양에서 메서드란 ES6 메서드 축약 표현만을 의미한다.
<br />
즉, 함수가 어떻게 정의되었는지에 따라 `constructor`와 `non-constructor`를 구분한다.

함수 선언문과 함수 표현식으로 정의된 함수는 `constructor`이며, 화살표 함수와 메서드 축약 표현은 `non-constructor`이다.

함수를 일반적으로 호출하면 내부 메서드 `[[Call]]`이 호출되며, `new 연산자`를 사용하면 `[[Construct]]`가 호출된다.
<br />
`non-constructor` 함수는 `[[Construct]]` 메서드를 가지지 않으므로, 이를 생성자 함수로 호출하면 에러가 발생한다.

```javascript
function foo() {}

// 일반 함수로 호출
foo(); // [[Call]]이 호출된다.

// 생성자 함수로 호출
new foo(); // [[Construct]]가 호출된다.
```

> ⚠️ 생성자 함수로서 호출될 것을 기대하지 않고 정의된 일반 함수에 `new 연산자`를 붙여 호출하면, 이는 생성자 함수처럼 동작하지 않고 에러가 발생하게 된다.

---

## 17.2.6 new 연산자

- 일반 함수와 생성자 함수에 특별한 형식적 차이는 없다.
- `new 연산자`와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다.
- 함수 객체의 내부 메서드 `[[Call]]`대신 `[[Construct]]`가 호출된다.
- 단, `new 연산자`와 함께 호출하는 함수는 `non-constructor`가 아닌 `constructor`이어야 한다.

```javascript
// 생성자 함수로 정의하지 않은 일반 함수
function add(x, y) {
  return x + y;
}

let inst = new add();
// 빈 객체가 생성된다.
console.log(inst); // {}

// 객체를 반환하는 함수
function createUser(name, role) {
  return { name, role };
}

inst = new createUser("Yeo", "admin");
console.log(inst); // {name: "Yeo", role: "admin"}
```

반대로, `new 연산자` 없이 생성자 함수를 호출하면 일반 함수로 동작한다.
<br />
즉, `[[Construct]]`가 아닌 `[[Call]]`이 호출된다.

```javascript
// 생성자 함수
function Circle(radius) {
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// new 연산자 없이 호출하면 일반 함수처럼 동작
const circle = Circle(5);

console.log(circle); // undefined
console.log(radius); // 5
console.log(getDiameter()); // 10
```

Circle 함수를 `new 연산자` 없이 호출하면 this는 전역 객체인 window를 가리킨다.
<br />
따라서 radius와 getDiameter는 전역 객체의 프로퍼티와 메서드가 된다.

일반 함수와 생성자 함수에는 명확한 형식적 차이가 없다.
<br />
다만, 생성자 함수는 보통 첫 문자를 대문자로 명명해 파스칼 케이스로 구별하는 것이 일반적이다.

---

## 17.2.7 new.target

new 연산자 없이 생성자 함수가 호출되는 것을 방지하기 위해 ES6에서는 `new.target`이 도입되었다.
<br />
`new.target`은 `constructor` 함수 내부에서 암묵적인 지역 변수처럼 사용되며, new 연산자가 사용되었을 때는 함수 자신을 가리키고, 그렇지 않으면 undefined를 반환한다.

```javascript
// 생성자 함수
function Circle(radius) {
  if (!new.target) {
    // new 연산자와 함께 재호출하여 인스턴스를 반환
    return new Circle(radius);
  }
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// new 연산자 없이 호출해도 new.target을 통해 생성자 함수로 재호출
const circle = Circle(5);
console.log(circle.getDiameter()); // 10
```

### 스코프 세이프 생성자 패턴 (Scope-safe Constructor)

`new.target`을 지원하지 않는 환경에서는 스코프 세이프 생성자 패턴을 사용할 수 있다.
<br />
`this instanceof`를 사용해 `new 연산자`와 함께 호출됐는지 확인하고, 그렇지 않으면 `new 연산자`를 사용해 생성자 함수를 재호출한다.

```javascript
// Scope-safe Constructor Pattern
function Circle(radius) {
  if (!(this instanceof Circle)) {
    return new Circle(radius);
  }
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

const circle = Circle(5);
console.log(circle.getDiameter()); // 10
```

`new 연산자`와 함께 생성된 객체는 프로토타입을 통해 생성자 함수와 연결된다.
<br />
이를 통해 `new 연산자`가 사용되었는지 확인할 수 있다.

### 빌트인 생성자 함수

대부분의 빌트인 생성자 함수(Object, String, Number, Boolean 등)는 `new 연산자` 없이 호출해도 적절한 값을 반환하거나 동일하게 동작한다.

```javascript
let obj = new Object();
console.log(obj); // {}

obj = Object();
console.log(obj); // {}

let f = new Function("x", "return x ** x");
console.log(f); // ƒ anonymous(x) { return x ** x }

f = Function("x", "return x ** x");
console.log(f); // ƒ anonymous(x) { return x ** x }
```

반면, String, Number, Boolean 생성자 함수는 `new 연산자` 없이 호출하면 해당 기본 값을 반환하여 데이터 타입 변환에 사용될 수 있다.

```javascript
const str = String(123);
console.log(str, typeof str); // 123 string

const num = Number("123");
console.log(num, typeof num); // 123 number

const bool = Boolean("true");
console.log(bool, typeof bool); // true boolean
```
