## 연산자
- 연산자 : 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 등을 수행하여 하나의 값을 만듦
- 피연산자 : 연산의 대상 (값으로 평가될 수 있는 표현식)
- 연산자 표현식 : 피연산자 + 연산자의 조합 (값으로 평가될 수 있는 표현식)
<br>
```
//산술 연산자
5 * 4 // 20

//문자열 연결 연산자
'my name is ' + 'Lee' // my name is Lee

//할당 연산자
color = 'red'

//비교 연산자
3 > 5 //false

//논리 연산자
true && false // false

//타입 연산자
type of 'Hi' // string
```

### 🧹 용어 정리
- 피연산자 : __"값"__ 이라는 명사 역할
- 연산자 : __"피연산자를 연산하여 새로운 값을 만든다"__ 라는 동사 역할

- 피연산자는 __연산의 대상__ 이 되어야 하므로 값을 __평가__ 할 수 있어야한다.
- 연산자는 __값__ 으로 평가된 피연산자를 연산해 __새로운 값__ 을 만든다.

예시)
```
a > b 
// a , b 는 피연산자
// > 연산자
```

### 1. 산술 연산자
피연산자(값)를 대상으로 수학적 계산을 수행하여 새로운 숫자 값을 만든다.<br>
산술 연산이 불가능할 경우 NaN을 반환한다.<br>
_NaN : Not a Number_ <br>

피연산자 개수에 따라서 이항 산술 연산자 / 단항 산술 연산자로 구분

#### 1.1 이항산술 연산자
두개의 피연산자를 산술하여 숫자 값을 만듦<br>
모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수효과가 없다.<br>
_즉, 어떤 산술연산을 해도 피연산자 값이 바뀌는 경우는 🙅🏻‍♀️_
_항상 새로운 값을 만듦 ✅_

(사진)

예제)
```
5+2 //7
5-2 //3
5*2 //10
```

#### 1.2 단항 산술 연산자
1개의 피연산자를 산술 연산하여 숫자 값을 만든다.

(사진)

⚡️ 주의할 점 : 증가 / 감소 (++/--) 연산자는 부수효과가 있다.

이때 증가 감소 연산자의 위치에 따라 값이 달라진다.<br>
- 피연산자(변수)앞에 위치한 증가/감소 연산자는 먼저 값을 증가/감소 시킨 후, 다른 연산 수행
- 피연산자(변수) 뒤에 위치한 증가/감소 연산자는 먼저 다른 연산을 실행한 후, 피연산자의 값을 증가/감소 시킴

예시)
```
var x = 5, result;

//선할당 후 증가
result = x++;
console.log(result,x); //5 6

//선증가 후 할당
result = ++x;
console.log(result,x); //7 7

//선할당 후 감소
result = x--;
console.log(result,x); //7 6

//선감소 후 할당
result = --x;
console.log(result,x); //5 5
```

'-' 단항 연산자는 '+' 단항 연산자와 다르게 피연산자의 부호를 반전한 값을 반환한다.<br>
'+' 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에서 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.<br>

예시)
```
-(-10) // 10;
-'10'; // -10(문자열을 숫자타입으로 변환)
-true; // -1 (불리언 값을 숫자로 변환)
-'hello' // 문자열은 숫자로 타입 변환할 수 없으므로 NaN
```

### 1.3 문자열 연결 연산자
'+' 연산자는 피연산자가 하나 이상의 문자열인 경우 문자열 연결 연산자로 동작한다.

예시)
```
//문자열 연결 연산자
'1' + 2 // 12
1 + '2' // 12

//산술 연산자
1 + 2; //3

//true는 1로 타입 변환된다.
1 + true //2

//false는 0 으로 타입 변환
1 + false //1

//null은 0 으로 타입 변환
1 + null //1

//undefined는 숫자로 타입 변환되지 않는다.
+undefined; // NaN
1 + undefined; // NaN
```

여기서 볼 수 있듯 개발자의 의도와 상관 없이 JS엔진에 의해 암묵적 타입이 자동 변환이 된다.<br>
예시로 언급하였듯 `1+true` 가 2가 나오듯 강제로 변환 후 연산을 수행한다.<br>
이를 __암묵적 타입 변환__ 또는 __타입 강제 변환__ 이라고 한다.

### 2. 할당 연산자
우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당

(사진)

예시)
```
var x = 10;

x + = 5; // x = x + 5;
console.log(x); //15

x -= 5; // x = x - 5;
console.log(x); //10

var str = 'My name is ';

str += 'Lee'
console.log(str); //My name is Lee
```

#### 😯 퀴즈.
```
var x;

//할당문
console.log(x=10); //10
```
__해당 할당문은 표현식인 문일까? 표현식이 아닌문일까?__

__정답__
할당문은 표현식인 문이다.<br>

위의 예제를 참고하면 `x = 10` 은 x에 할당된 숫자 값 10으로 평가된다.<br>
따라서, 할당문을 다른 변수에 할당할 수 있다.<br>
이런 특징을 이용하여 여러 변수에 동일한 값을 연쇄 할당할 수 있다.

```
var a,b,c;

//연쇄 할당 . 오른쪽에서 왼쪽으로 진행.
a = b = c = 0;
console.log(a,b,c) // 0 0 0
```

### 3. 비교 연산자
좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.<br>
if문이라 for문 같은 제어문의 조건식에서 주로 사용된다.

#### 3.1. 동등 / 일치 비교 연산자
좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교하여 boolean값 으로 반환<br>
- 동등 비교 연산자(==) : 느슨한 비교
- 일치 비교 연산자(===) : 엄격한 비교

(사진)

JS엔진은 암묵적 타입 변환을 실행.<br>

동등 비교 연산자(==)는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.

```
5 == '5' //true
```

그러나 동등 비교 연산자는 오류를 발생할 가능성이 크다.

안티 패턴예시)
```
'0' == ''; // false
false == 'false'; //false
false == '0'; // true
```

이러한 예측하기 어려운 결과를 만들어내는 __동등 비교 연산자(==)__ 대신 
일치 비교 연산자(===) 를 사용한다.

이는 좌항과 우항의 피연산자가 타입도 같고 값도 같을때만 true를 반환한다.
```
5 === '5' // false
```

__➕ 추가 개념__ <br>

Object.is 메서드<br>
이는 ES6에서 도입된 메서드이며 예측 가능한 정확한 비교 결과를 반환다.<br>
하단의 예시 이외에는 일치 비교 연산자(===)과 동일하게 동작한다.

```
-0 === +0; //true;
Object.is(-0, +0); //false;

NaN === NaN; //false;
Object.is(NaN,NaN); // true
```

#### 3.2 대소 관계 비교 연산자
(사진)