# OOP의 기둥들

객체 지향 프로그래밍(OOP)은 4가지의 기둥이 있습니다.

- 추상화
- 캡슐화
- 상속
- 다형성

<br />

## 추상화

```
추상화란 사물이나 표상을 어떤 성질, 공통성, 본질에 착안하여 그것을 추출하여 파악하는 것
객체지향 프로그래밍에서 추상화는 각 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 의미한다.
```

추상화는 공통적인 속성과 기능을 추출하여 코드를 재사용성이 높아지고 반복 코드를 활용하지 않음으로써 코드의 효율성도 높아지게 된다는 장점이 있습니다.

<br />

### Airplane(비행기) 클래스로 예시를 들어본다면?

<center>
  <img width="437" alt="1" src="https://github.com/spaaaams/boook/assets/80776262/74f1a0c6-edae-459d-aae0-31f21b17e7ea">
</center>

Airplane 클래스라고 한다면 비행 시뮬레이터와 항공 좌석 예약 앱 등등 있는 경우가 있습니다.
<br />
비행 시뮬레이터가 실제 비행과 관련된 세부 정보들을 담고 있다면,
<br />
항공 좌석 예약 앱에서 사람들이 신경 쓰는 건 좌석 배치도와 예약 가능한 좌석들 같은 정보들뿐입니다.

이렇게 추상화는 불필요한 세부 사항들은 제거하고 가장 본질적이고 공통적인 부분만을 추출하여 표현하여 많은 이점을 가져다줍니다.

<br />

## 캡슐화

```
캡슐화는 객체의 특정 프로퍼티와 메소드에 직접 접근하지 못하도록 막는 것이다.
서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로 부터 보호하는 것을 말한다. 
```

자동차의 시동을 걸려면 운전자는 버튼을 누르거나 키만 돌리면 됩니다.
<br />
그 외 후드 아래에 있는 전선들을 연결하고, 크랭크축과 실린더를 회전시켜 엔진의 전원 사이클을 시작해야하는 복잡한 일들은 필요가 없습니다.
<br />

복잡하고 내부적인 기능들은 자동차 후드안에 숨겨져 있기 때문에 운전자는 신경 쓸 필요가 없습니다.
<br />
운전자 입장에서는 시동 버튼, 핸들, 패달 등 운전에만 필요한 것들만 알고 있게되는데 이것을 자동차라는 객체에 인터페이스를 갖는 방식을 보여줍니다.
<br />

운전자가 운전에 필요한 기능들을 제외한 나머지 복잡한 기능들은 운전자가 사용을 못하게 외부로부터 보호하고 있으며 캡슐화의 예시가 됩니다.
<br />

### 왜 외부로 부터 보호해야 할까?

큰 이유는 데이터 보호와 데이터 은닉의 이유 때문입니다.
<br />
외부로 부터 각 객체에 정의된 속성과 기능들을 보호하고 내부의 동작을 감추고 외부에 필요한 부분만 노출시키기 위함입니다.
<br />
또한 캡슐화를 함으로써 객체를 활용하는 다른 사용자들의 실수를 방지할 수 있는 역할도 가능합니다.

<br />

## 상속

```
상속은 기존 클래스들 위에 새 클래스들을 구축하는 기능
```

상속을 사용하면 결과적으로 자식 클래스들이 부모 클래스와 같은 인터페이스를 갖게 됩니다.
<br />
어떤 메서드가 부모 클래스에서 선언되었다면 자식 클래스에서 그 메서드를 숨길 수 없습니다.
<br />
또한 자식 클래스들에 어울리지 않는 추상 메서드들을 포함하여 모든 추상 메서드들을 구현해야 합니다.

<br />

### 상속의 이점?

상속을 가장 큰 이점은 코드의 재사용 입니다.
<br />
상속을 사용하게 되면 반복적인 코드 사용이 줄어들게 되는데 이를 코드재사용성이 좋아진다고 말할 수 있습니다.

<br />

## 다형성

```
다형성은 많은 형태를 갖고 있는 성질을 말한다.
객체지향프로그래밍에서 다형성은 하나의 변수가 다양한 종류의 객체를 가리키는 것을 말한다.
```

### Animal(동물) 클래스로 예시를 들어본다면?

Animal 클래스로 예시를 들어봅니다.
<br />
대부분의 동물들은 울음소리를 낼 수 있기에 Animal 클래스를 상속받는 모든 자식클래스는 울음소리를 낼 수 있어야 합니다.
<br />
Animal 클래스를 구현한다면 상속받는 자식클래스는 makeSound 라는 메소드를 오버라이딩하여 사용할 수 있습니다.
<br />
이때 makeSound 메소드는 `추상 메소드`로 선언을 할 수 있습니다.
<br />

부모 클래스에서 추상 메소드로 선언을 하게되면 상속받는 자식 클래스는 강제적으로 해당 메소드를 각자 구현해야합니다.

<center>
  <img width="554" alt="2" src="https://github.com/spaaaams/boook/assets/80776262/b915bc62-c39f-4afb-a611-266cbd37a99c">
</center>

<br />

큰 가방에 여러 고양이와 개들을 넣었다고 가정해 봅시다.
<br />
그런 다음 눈을 감은 상태에서 가방에서 동물들을 하나씩 꺼내는 겁니다.
<br />
가방에서 동물을 꺼낸 직후 당신은 그 동물이 어떤 동물인지 확실히 모릅니다.
<br />
하지만 그 동물을 힘껏 껴안아 본다면 이 동물은 그 구상 클래스에 따라 특정한 소리를 낼 것입니다.
<br />

```typescript
abstract class Animal {
  abstract makeSound(): void;
}

class Cat extends Animal {
  public makeSound() {
    console.log("야옹!");
  }
}

class Dog extends Animal {
  public makeSound() {
    console.log("멍멍!");
  }
}

const bag = [new Cat(), new Dog()];

bag.forEach((a) => a.makeSound());

// 야옹!
// 멍멍!
```

프로그램은 a 변수 안에 포함된 객체의 구상 유형을 알지 못합니다.
<br />
하지만 다형성이라는 특별한 메커니즘 덕분에, 프로그램은 그 메서드가 실행되어 적절한 행동들을 실행하는 객체의 자식 클래스를 추적할 수 있습니다.
<br />

다형성은 객체의 실제 클래스를 감지하고 해당 객체의 구현을 현재 맥락에서 이것의 실제 유형을 알 수 없는 경우에도 호출할 수 있는 프로그램의 기능입니다.
<br />

다형성은 객체가 다른 무언가인 척 '가장'을 할 수 있는 기능이라고도 생각할 수 있습니다.
<br />
일반적으로는 객체가 확장하는 클래스 또는 구현하는 인터페이스인 척 가장합니다.
<br />
위 예시에서는 가방에 든 개와 고양이가 일반적인 동물인 척 가장하고 있었습니다.
