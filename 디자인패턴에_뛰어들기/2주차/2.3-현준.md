# 구현이 아닌 인터페이스에 대해 프로그래밍하세요

> 구상 클래스에 의존하는 대신 추상화에 의존하세요.

> 기존의 코드를 망가뜨리지 않고 쉽게 확장할 수 있다면 그 디자인은 충분히 유연하다고 할 수 있습니다.

🤔 예시) **모든 음식**을 먹을 수 있는 고양이 VS **소시지만** 먹을 수 있는 고양이

- 소시지는 모든 음식의 **부분 집합** ➡️ <u>모든 음식을 먹을 수 있는 고양이가 더 유연함</u>
- 모든 음식을 먹을 수 있는 고양이는 어떤 음식으로도 **확장**이 가능

만약 두 클래스가 서로 같이 작업하도록 만드려면 어떤 방법이 있을까요?

## 객체 간의 공동 작업을 만드는 유연한 방법 ❓

1. 한 객체가 다른 객체에서 정확히 무엇을 필요로 하는지, 어떤 메서드를 실행하는지?
2. 새 인터페이스 또는 추상 클래스에서 해당 메서드를 설명하도록
3. 다른 객체에 **의존하는 클래스**가 해당 **인터페이스를 구현**하도록
4. 두 번째 클래스를 구상 클래스가 아닌 해당 **인터페이스에 의존**하도록

![](https://velog.velcdn.com/images/yongvelopeer/post/f017838e-9bc9-4906-9e81-2aa76b5a11af/image.png)

인터페이스를 추출하기 전(왼쪽)과 후(오른쪽)입니다.

추출한 후가 더 유연하지만 코드는 전보다 복잡해졌습니다.

하지만 기능을 확장할 수 있는 포인트가 될 수 있습니다.

## 예시 👀

> 해당 예시는 객체의 구상 클래스에 의존하는 것 보다 인터페이스를 통해 작업하는 것이 좋을 수 있다는 예시를 보여줍니다.

![](https://velog.velcdn.com/images/yongvelopeer/post/3f5db3af-f8fa-423a-845f-332e6558831b/image.png)

### 문제점 ⁉️

- `Company` 클래스가 직원들의 구성 클래스들과 밀접하게 **결합**되어 있습니다.
- 즉, `Company` 클래스가 **각 직원 클래스에 의존**하게 되는 문제가 발생합니다.

### 해결 방법 Step.1

1. 다양한 업무 관련 메서드를 **일반화** 할 수 있습니다.
2. 모든 직원 클래스에 대한 **공통 인터페이스를 추출** 할 수 있습니다.
3. `Company` 클래스 내부에 다형성을 적용하여 `Employee` 인터페이스를 통해 다양한 직원 객체들을 처리합니다.

![](https://velog.velcdn.com/images/yongvelopeer/post/f4fe70fb-c725-4bb0-a6b3-ec69de412f38/image.png)

하지만 위 방법도 완벽하지 않습니다.

`Company` 클래스는 여전히 각 직원 클래스에 연결되어 있습니다.

만약 다른 유형의 직원과 함께 일하는 새로운 유형의 회사들을 소개 하려면 이 클래스의 대부분을 오버라이드를 해야하는 문제가 발생합니다.

### 해결 방법 Step.2

직원을 가져오는 메서드를 *abstract*로 선언할 수 있습니다.

- 각 구상 회사는 해당 메서드를 다르게 구현하게 됩니다.
- 자기 회사에 필요한 직원들만 만들 수 있습니다.

![](https://velog.velcdn.com/images/yongvelopeer/post/beb2eff5-bf95-49ba-be16-2b068b3191ea/image.png)

이렇게 개선함으로써 `Company` 클래스는 다양한 직원 클래스에서 독립되었습니다.

또한, 기초 회사 클래스의 일부를 재사용 하면서 확장할 수 있습니다.

앞서 설명한 내용이 바로 `팩토리 메서드` 패턴의 예시였습니다.
