## 옵저버 패턴
옵저버 패턴은 우리가 관찰중인 객체에 발생하는 모든 이벤트에 대하여 알리는 행동 디자인 패턴입니다.
<br>

### 🤨 문제
`Customer` (손님) 및 `Store`(가게) 라는 두가지 유형의 객체가 있습니다.<br>
손님은 곧 매장에서 출시될 아이폰16에 매우 관심이 있습니다.

이때 두가지 방법으로 아이폰16을 살 수 있습니다. <br>

(사진)

__1. 손님이 매일 매장을 방문__ <br>
손님이 매일 매장을 방문하여 제품의 제고를 확인할 수 있지만, 제품이 매장에 없는경우 이러한 방문은 무의미합니다.<br>

__2. 매장에서 문자 발송__ <br>
매장에서는 새로운 제품이 출시될 때마다 모든 고객에게 스팸으로 간주할 수 있는 이메일을 보낼 수 있습니다.
이 방법은 1번방법과 달리 제품을 필요로 하는 고객에게는 좋은수단이 될 수 있지만, 해당 제품에 관심이 없는 다른 고객들을 화나게 할 것입니다.

😱 1,2번 두가지 방법 모두 자원을 낭비하는 방법이므로 올바른 방법이 아닙니다.

### 😯 해결책
_시간이 지나면 변경될 수 있는 중요한 상태를 가진 객체가 있다고 가정_
<br>
이객체는 종종 __주제(subject)__ 라고 불립니다.<br>
그러나, 위의 아이폰16과 같은 경우 이 객체는 자신의 상태에 대한 변경에 대해 다른 객체 __(아이폰 16을 원하는 다른 사람들)__ 에게도 알림을 보내는 역할도 맡을 것이니 해당 객체를 __출판사__ 라고 부르겠습니다.

옵저버 패턴은 __출판사 클래스__ 에 출판사로부터 오는 이벤트들의 알림들을 __구독 혹은 구독취소__ 할 수 있도록 구독 메커니즘을 추가할 것을 제안합니다.

#### 구독 메커니즘
1. 구독자 객체들에 대한 참조 리스트를 저장하기 위한 배열필드
2. 리스트에 구독자들을 추가하거나 제거할 수 있도록 하는 여러 공개된(public) 메서드들로 구성

이제 출판사에 중요한 일(이벤트 발생) 이 있을 때마다 구독자 리스트를 참조 후 그들의 객체들에 있는 알림 메서드를 호출

(사진)

#### 실제 어플의 경우
__같은 출판사 클래스의 이벤트를 추적__ 하는데 관심이 있는 __수십개의 서로 다른 구독자 클래스__ 가 존재할 수 있다.

그러나, 우리는 이렇게 수많은 구독자 클래스에 우리의 출판사를 결합하고 싶지 않을 것이다.
<br>

게다가 우리는 출판사 클래스가 __다른사람__ 에 의해 사용 되어야한다면? 수많은 구독자 클래스 중 일부를 알지 못 할 수도 있다.

즉! 모든 구독자가 같은 인터페이스를 구현하고, 출판사는 그 인터페이스를 통해서만 통신하는 것이 매우 중요하다.

이 인터페이스는 출판사가 알림과 __텍스트 데이터를 전달하는데 사용하는 매개변수들의 집합__ 과 __알림 메서드__ 를 선언해야한다.

(사진)

우리의 어플에 여러 출판사(한빛미디어 / 문학동네 현대문학)가 있고<br>
이를 구독자들과 호환되게 하려면?<br>
=> 모든 출판사가 같은 인터페이스를 따르도록 할 수 있습니다.

이 인터페이스를 통해 구독자는 출판자들의 상태를 구상 클래스들과 결합하지 않고, 관찰할 수 있다.
### ♻️ 적용
- 한 객체의 상태가 변경되어 다른 객체를 변경해야할 필요성이 생겼을 때
- 실제 객체 집함들을 미리 알 수 없거나, 이러한 집합들이 동적으로 변경될 때 사용
- 일부 객체들이 제한된 시간동안 or 특정 경우에만 다른 객체를 관찰해야할 때 사용
    - 구독 리스트는 동적이므로 구독자들은 필요할 때마다 리스트에 가입하거나, 탈퇴할 수 있다.


### ✅ ❎ 장단점
👍 장점
- 실시간으로 한 객체의 변경사항을 다른 객체에 전파 가능
- 느슨한 결합으로 시스템이 유연하고 객체간의 의존성 제거할 수 있다.

👎 단점
- 과잉 사용은 상태관리가 힘들어질 수 있다.

### ✍️ 실제 적용
리액트에서 옵저버 패턴을 사용하는 대표적인 예시는 React Query이다.