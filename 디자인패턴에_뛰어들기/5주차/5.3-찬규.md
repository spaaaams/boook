# 🌉 브리지 패턴 (Bridge Pattern)

**브리지**는 큰 클래스 또는 밀접하게 관련된 클래스들의 집합을 `두 개의 개별 계층구조​(추상화 및 구현)`​로 나눈 후 
<br />
각각 독립적으로 개발할 수 있도록 하는 구조 디자인 패턴입니다.

<br />

## ☹️ 문제 직면!

`Circle`및 `Square`라는 한 쌍의 자식 클래스들이 있는 `Shape`클래스가 있다고 가정해 봅시다.
<br />
이 클래스 계층 구조를 확장하여 *색상*을 도입하기 위해 `Red`및 `Blue`모양들의 자식 클래스들을 만들
계획입니다.
<br /> 
그러나 이미 두 개의 자식 클래스가 있으므로 `BlueCircle`및 `RedSquare`와 같은 네
가지의 클래스 조합을 만들어야 합니다.
<br />

<p align="center">
  <img src="https://refactoring.guru/images/patterns/diagrams/bridge/problem-ko.png?id=d6a269defe845caae2181e1568256f16" alt="브리지 패턴 문제" width="480" />
</p>
<p align="center">
  ❗클래스 조합들의 수는 <strong>기하급수적으로 증가</strong>하게됩니다.
</p>

<br />

새로운 모양 유형들과 색상 유형들을 추가할 때마다 계층 구조는 **기하급수적으로 증가**하는 문제가 발생합니다.
<br />
예를 들어, 삼각형 모양을 추가하려면 각 색상별로 하나씩 두 개의 자식 클래스들을 도입해야 합니다.
<br />
그리고 그 후에 또 새 색상을 추가하려면 각 모양 유형별로 하나씩 세 개의 자식 클래스를 만들어야 합니다.
<br />
유형들이 많아지면 많아질수록 코드는 점점 복잡해집니다.

<br />

## 🧐 해결책

> _🔍 문제점 파악_ <br />
>
> 해당 상황은 **모양**과 **색상**의 두 가지 독립적인 차원에서 모양 클래스들을 확장하려고 하기 때문에 발생합니다.
> <br />
> 이것은 클래스 상속과 관련된 매우 일반적인 문제입니다.

<br />

해당 문제점은 `브리지 패턴`을 통해 *상속에서 객체 합성으로 전환*하여 문제를 해결할 수 있습니다.
<br />
이는 클래스의 여러 차원 중 *하나를 별도의 클래스 계층 구조로 분리*하는 것을 의미합니다.
<br />
결과적으로, 원래 클래스들이 한 클래스 내에서 모든 상태와 행동들을 갖는 대신 *새 계층구조의 객체를 참조하도록 하는 것*입니다.
<br />

<p align="center">
  <img src="https://refactoring.guru/images/patterns/diagrams/bridge/solution-ko.png?id=5e4d726b4474819783501d71f7ce96f9" alt="브리지 패턴이 제시하는 해결책" width="460" />
</p>
<p align="center">
  ✔️클래스 계층구조의 기하급수적인 증가를 방지하기 위해 여러 관련 계층구조들로 변환할 수 있습니다.
</p>

<br />

1. 색상 관련 기능을 `Red`및 `Blue`라는 두 개의 자식 클래스들이 있는 `Color`클래스로 추출할 수 있습니다.
2. 그 후 `Shape`클래스는 `Color`객체들 중 하나를 가리키는 참조 필드를 받습니다.
3. 이제 `Shape`은 연결된 `Color`객체에 모든 색상 관련 작업을 위임할 수 있습니다.

이 참조는 `Shape`및 `Color`클래스들 사이의 `다리(Bridge)`역할을 합니다.
<br />
이제부터 새색상들을 추가할 때 `Shape` 계층구조를 변경할 필요가 없으며 해당 문제가 해결이 됩니다.

<br />

### 🗃️ `추상화`와 `구현` 계층구조

브리지 패턴의 핵심은 "`추상화 계층구조`와 `구현 계층구조` 두 계층구조를 연결한다" 입니다.

```
추상화 계층 ||=========|| 구현 계층
```

<br />

`추상화(=인터페이스)`는 일부 개체(entity)에 대한 상위 수준의 제어 레이어 입니다.
<br />
이 레이어는 자체적으로 **실제 작업을 수행해서는 안 되며**, 작업들을 **`구현 레이어(=플랫폼)`에 위임**해야 합니다.

> ⚠️ 주의사항
> <br />
> 여기서 언급한 추상화의 개념은 프로그래밍의 `인터페이스`이나 `추상 클래스`를 말하는게 아닙니다.

<br />

실제 앱을 예로 들면 `추상화`는 *그래픽 사용자 인터페이스* 이며,
<br />
`구현`은 *그래픽 사용자 인터페이스 레이어가 사용자와 상호작용하여 그 결과로 호출하는 배경 운영 체제 코드(=API)* 입니다.

<br />

일반적으로 이러한 앱은 두 가지 독립적인 방향으로 확장할 수 있습니다.

- 다른 그래픽 사용자 인터페이스를 가진다.<br />(일반 고객 또는 관리자용으로 맞춘 인터페이스)
- 여러 API들을 지원한다.<br />(맥, 리눅스 및 윈도우에서 앱을 실행할 수 있는 API)

최악의 경우 이 앱이 수백 개의 조건문들이 코드 전체에 다양한 API와 다양한 유형의 그래픽 사용자 인터페이스들을 연결한 거대한 스파게티 코드가 형성 될 수 있습니다.

<p align="center">
  <img src="https://refactoring.guru/images/patterns/content/bridge/bridge-3-ko.png?id=30aba648afd595b26c336f43970d9bfe" alt="모듈성 코드는 변경 관리가 훨씬 쉽습니다" width="600" />
</p>
<p align="center">
  ❌ 모놀리식 코드베이스는 <u>간단한 변경을 하는 것조차 매우 어렵습니다.</u>
  <br />
  ⭕ 반면에 잘 정의된 <u>작은 모듈들을 변경하는 것은 훨씬 쉽습니다.</u>
</p>

<br  />

특정 인터페이스-플랫폼 조합들과 관련된 코드를 별도의 클래스들로 추출하여 복잡함을 해소할 수 있습니다.
<br />
하지만 점점 클래스들이 증가 하게된다는 문제가 발생하게 됩니다.
<br />

즉, 새로운 그래픽 사용자 인터페이스를 추가하거나 다른 API를 지원하려면 점점 더 많은 클래스를 생성하게 되고,
<br />
이로인해 클래스 계층구조는 기하급수적으로 증가하게 됩니다.
<br />

브리지 패턴은 해당 문제를 해결하기 위해 <u>두 가지 계층을 분리</u>하여 독립적인 개발을 할 수 있도록 합니다.

- 추상화 계층: 그래픽 사용자 인터페이스 레이어
- 구현 계층: 운영 체제의 API

<p align="center">
  <img src="https://refactoring.guru/images/patterns/content/bridge/bridge-2-ko.png?id=46cfc1de98dbc4ede4edacea48755e6f" alt="크로스 플랫폼 아키텍처" width="640" />
</p>

추상화 객체는 앱의 드러나는 모습을 제어하고 연결된 구현 객체에 실제 작업들을 위임합니다.
<br />
서로 다른 구현들은 공통 인터페이스를 따르는 한 상호 호환이 가능하며, 이에 따라 같은 그래픽 사용자 인터페이스는 리눅스와 윈도우에 동시에 작동할 수 있습니다.
<br />

따라서 API 관련 클래스들을 건드리지 않고 그래픽 사용자 인터페이스 클래스들을 변경할 수 있습니다.
<br />
그리고 다른 운영 체제에 대한 지원을 추가하려면 구현 계층구조 내에 자식 클래스를 생성하기만 하면 됩니다.

<br />

## 🤓 구조

<p align="center">
  <img src="https://refactoring.guru/images/patterns/diagrams/bridge/structure-ko-indexed.png?id=b829023128a479e00dd63903ba10ba76" alt="브리지 디자인 패턴" width="560" />
</p>

1. 추상화: 상위  수준의 제어 논리를 제공하며, 구현 객체에 의존해 실제 하위 수준 작업들을 수행합니다.
2. 구현: 모든 구상 구현들이 공통적인 인터페이스를 선언하며, 추상화는 여기에 선언된 메서드들을 통해서만 구현 객체와 소통할 수 있습니다.
3. 구상 구현들: 플랫폼별 맞춤형 코드가 포함됩니다.
4. 정제된 추상화들: 제어 논리의 변형들을 제공하며 일반 구현 인터페이스를 통해 다른 구현들과 작업합니다.
5. 클라이언트: 추상화와 작업하는데만 관심이 있으나, 추상화 객체를 구현 객체들 중 하나와 연결하는 것도 클라이언트의 역할입니다.

<br />

## 🤓 의사코드

