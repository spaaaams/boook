### ✅ 싱글톤 패턴
--- 

싱글턴 패턴을 따르는 클래스는 생성자가 여러차례 호출되더라도 실제로 생성되는 객체는 하나이다.
<br>
최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.
<br>
<br>
💡 쉽게 말해 싱글톤 패턴은 __객체의 인스턴스를 한개만 생성되게 하는 패턴__ 이다. 
<br>
<br>
우리가 전역 변수를 만들어 사용하는 __이유__ 와 비슷합니다.
<br>
➡️ 똑같은 데이터를 메서드마다 지역변수로 선언하여 사용하면 무의미함과 동시에 낭비이기에, __전역에서 한번만 데이터를 선언하고 가지고 오면 효율적__ 이기 때문입니다.
<br>

_⚠️ 그러나, 전역변수와 하는 역할은 완전히 다릅니다. ⚠️_

굳이..? ꖶዞ¿? 써야해..?
<br>

### 💡싱글톤 패턴을 사용하는 이유
__1.메모리 측면의 이점__
<br>
한개의 인스턴스만을 고정 메모리 영역에 생성하고, 추후 해당 객체를 접근할 때 메모리 낭비를 방지하기 위해서
<br>

__2.속도 측면의 이점__
<br>
생성된 인스턴스를 사용할 때 이미 생성된 인스턴스를 사용하여 속도 측면에서 이점이 존재

__3.데이터 공유하기 쉬움__
<br>
전역으로 사용하는 인스턴스이기에 다른 여러 클래스에서 데이터를 공유하며 사용할 수 있다.
<br>
but.. __⚠️ 그러나, 동시성 문제가 발생할 수 있으니 주의 ⚠️__

### 🤨 그래서 어디에 쓰이는데?
보통 싱글턴 패턴이 적용된 객체가 필요한 이유는 __객체가 리소스를 많이 차지하는 역할을 하는 무거울 클래스__ 일때 적합합니다.

#### 👍 싱글턴 패턴이 적용될때 좋은 상황
__1. 단 하나의 인스턴스가 필요한 경우__
<br>
예) DB연결계층 / PC객체 등등

__2.전역 상태 관리__
<br>
전역 상태를유지하며 여러곳에서 접근 해야하는 경우
<br>
예) 게임에서 현재 점수, 레벨, 아이템 등을 저장하는 GameManage 자체가 여기에 해당
<br>

__3.인스턴스 생성 비용이 높은 경우__
<br>
클래스의 인스턴스를 생성하고, 관리하는 비용이많이 드는 경우
<br>
예) DB의 연결 계층 생성
<br>

__✨ 대표적인 예시 - 데이터 베이스 연결 모듈__

데이터 베이스에 접속하는 작업은 그 자체로도 무거운 작업이다. 또한, 이렇게 연결하는 작업을 굳이 여러번 생성할 필요또한 ❎

이뿐만아니라 

- 디스크 연결
- 네트워크 통신
- DBCP 커넥션풀
- 스레드풀
- 캐시
- 로그 기록 객체

등에 이용된다.

#### 👍 전역 변수를 더 엄격하게 제어애햐야할 때 사용
싱글턴 패턴은 전역변수와 다르게 __클래스의 인스턴스가 하나만 있도록 보장__
<br>
캐시된 인스턴스는 싱글턴 클래스 자체를 제외하고 어떤 것과도 대체될 수 없다.

### 👾 예제
```
import axios from "axios";

class AxiosClient {
  private static instance: AxiosClient;

  private constructor() {}

  public static getInstance(): AxiosClient {
    if (!AxiosClient.instance) {
      AxiosClient.instance = new AxiosClient();
    }
    return AxiosClient.instance;
  }

  public async get<T>(url: string): Promise<T> {
    const response = await axios.get<T>(url);
    return response.data;
  }

  public async post<T, R>(url: string, data: T): Promise<R> {
    const response = await axios.post<R>(url, data);
    return response.data;
  }
}

export default AxiosClient.getInstance();

```

위코드에서 AxiosClient 클래스는 싱글턴 패턴을 구하고, getInstance 메서드를 통해 전역적으로 하나의 인스턴스만 생성 됩니다.

#### 1. privte constructor
클래스의 생성자를 private로 선언하여 외부에서 이 클래스를 인스턴스화 하지 못하게 한다.<br>
이렇게하면 new AxiosClient()와 같은 호출로 새로운 인스턴스 생성 불가

#### 2. private static instance: AxiosClient;
클래스 내부에서 자기 자시을 저장하는 정적 속성을 갖는다.<br>
이 속성은 단일 인스턴스를 저장

#### 3. public static getInstance():메소드
이 메서드는 클래스의 인스턴스를 반환합니다. 만약 인스턴스가 존재하지 않으면 새로 생성하고, 이미 존재하면 기존의 인스턴스를 반환한다.

#### 4. export default AxiosClient.getInstance();
AxiosClient.getInstance()를 통해 인스턴스를 생성하고 외부 모듈에서 이 인스턴스를 사용할 수 있도록 한다.


즉 이 코드에서 AxiosClient.getInstance() 를 호출하면 항상 동일한 AxiosClient 인스턴트를 얻을 수 있기에 싱글턴 패턴이라고 하는 것이다.

### 👎 단점

#### 1. 상태 변화를 조심스럽게 다루어야합니다.
전역 상태를 유지하기 때문에 다수의 클라이언트가 해당 인스턴스에 접근하고, 수정할 수 있습니다.

#### 2. 멀티 스레드 환경에서 동시성 문제 발생
여러 스레드가 동시에 인스턴스를 생성하려고할 때, 싱글톤 인스턴스가 하나 이상으로 생성될 가능성이 있습니다.
<br>
-> 정적변수에서의 인스턴스 생성
<br>
-> 이러한 문제를 처리하기 위하여 동기화 처리를 해주어야하는데 이는 성능저하가 일어날 수 있으므로 신중하게 고려해야합니다.

#### 3. 초기화 과정이 복잡하거나, 오래걸릴 경우 어플리케이션 시작 속도가 느려질 수있음
싱글톤 객체를 생성할때면 초기화 과정을 거치는 경우가 많습니다.

이러한 경우 지연초기화(lazy initialization) 기법을 사용하거나, 필요한 시점에 초기화하는 방법을 사용할 수 있습니다.

#### 4. 싱글톤 객체는 객체지향적인 설계에서 문제 발생 가능성 있음

객체 지향적인 설계에서는 객체의 상태와 행위를 캡슐화하여 응집도와 결합도를 유지해야합니다.<br>
그러나, 싱글톤 객체의 상태와 행위를 모두 정적으로 구현하기 때문에, 객체지향적인 설계 원칙을 위반할 수도 있습니다.

> 정적으로 구현된다 <br>
이는 해당 객체가 전역에서 유일하게 존재하는 것으로 정적인 특징을 가진다는 것. <br>
객체의 상태와 행위가 변경되지않고, 항상일정하게 유지