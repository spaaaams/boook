# 책임 연쇄 패턴

> 책임 연쇄 패턴이란?💡
>
> - 핸들러들의 체인(사슬)을 따라 **요청을 전달**할 수 있는 디자인 패턴
> - 각 핸들러는 요청을 처리할지, 다음 핸들러로 전달할지를 결정

## 예시

### 상황

![](https://velog.velcdn.com/images/gazagaza/post/2a69c252-14d0-4bff-be73-4d29cf90f6d8/image.png)

우리는 **온라인 주문 시스템**을 개발하고 있습니다.

우리는 <u>인증된 사용자</u>들만 **주문을 생성**할 수 있도록 해야합니다.

또한, <u>관리 권한</u>이 있는 사용자들에게는 모든 주문에 대한 **전체 접근 권한**을 부여해야야합니다.

---

이후, 우리는 약간의 설계를 했습니다.

그리고 이러한 검사들은 차례대로 수행해야 한다는 사실을 깨달았습니다.

자격 증명이 포함된 요청을 받을 때마다 사용자 인증을 시도합니다.

하지만 만약, 자격 증명이 올바르지 않아서 인증 실패를 하면 다른 검사들을 진행할 이유가 없습니다.

### 문제 발생

![](https://velog.velcdn.com/images/gazagaza/post/008c3ea4-a361-455f-a53f-783109bc8b62/image.png)

이러한 상황에서 여러가지 검사가 더 추가 된다고 하면 유지보수성이 매우 떨어집니다.

즉, 검사하는 코드 안에 새로운 기능을 계속 추가 하다 보면 코드가 매우 커지고 다른 검사코드가 영향을 받을 확률도 높아집니다.

- ex) 데이터 정제 유효성 검사, 같은 IP 중복 요청 방지, 캐시가 없을 때만 요청이 전달되도록 등등...

### 해결책

**책임 연쇄** 패턴을 적용할 수 있습니다.

![](https://velog.velcdn.com/images/gazagaza/post/aa3da16c-ac49-4e71-bb62-a17d1f04f464/image.png)

해당 패턴을 적용해서 특정 행동들을 <u>핸들러</u>라는 독립 실행형 객체로 변환합니다.

- 각 검사는 검사를 수행하는 **단일 메서드**가 있는 자체 클래스로 추출합니다.
- 이제 요청은 데이터와 함께 해당 메서드에 인수로 전달됩니다.

1. 즉, 하나의 핸들러가 주문 처리를 수행합니다.
2. 수행한 다음 요청을 이후 체인으로 전달할지 결정합니다.

> **정식적인 접근 방법**
>
> 1. 핸들러가 요청을 받고 처리할 수 있는지 판단
> 2. 처리가 가능한 경우 요청을 더이상 전달하지 않음.
> 3. 불가능한 경우 다음 핸들러로 요청을 전달

## 실제 상황 예시 🔍

![](https://velog.velcdn.com/images/gazagaza/post/9fb04573-f79d-4c46-bd09-7d5a34f4c7f2/image.png)

1. 상담 시도 (요청)
2. 자동 응답 처리
3. 상담원의 해결책 (핸들러)
4. 엔지니어의 해결책 (핸들러)

## 기본 구조 📂

![](https://velog.velcdn.com/images/gazagaza/post/f03e8fea-a6fc-4423-80f1-28e549fc2e34/image.png)

### 각 역할

1. 핸들러(Handler)

   - 모든 구상 핸들러의 공통 인터페이스
   - 일반적으로 요청을 처리하기 위한 단일 메서드가 포함

2. 기초 핸들러(BaseHandler)

   - 모든 핸들러 클래스들에 공통 상용구 코드를 넣을 수 있음
   - 다음 핸들러에 대한 참조를 저장하기 위한 필드를 정의

3. 구상 핸들러(ConcreteHandler)
   - 요청을 처리하기 위한 실제 코드가 포함
   - 요청을 처리할지, 다음 핸들러에 전달할지 결정
4. 클라이언트(Client)
   - 체인 구성

## 코드 예제 📖

## 구현 방법 📕

## 언제 적용하면 좋을까? 🧐

## 장단점 💫

### 장점 👍

### 단점 👎
