## 프록시 패턴
프록시(Proxy) : 대리자, 대변인 (누군가를 대신해서 그 역할을 수행하는 존재)

### 🤨 프로그래밍에선?
다른 객체에 대한 대체 혹은 자리표시자를 제공할 수 있다.
<br>
프록시는 원래 객체에 대한 접근 제어 -> 클라이언트의 요청이  객체에 전달되기 전 / 후에 무언가를 수행할 수 있다.

### ❗️ 객체에 대한 접근을 제어하는 이유는?
해당 질문에 답하기 위하여 __방대한 양의 시스템 자원을 소비하는 거대한 객체__ 가 있다고 가정
<br>
해당 객체가 필요하긴하지만 __"항상"__ 필요한 것은 ❌

<img width="343" alt="image" src="https://github.com/spaaaams/boook/assets/51051548/ad667418-aaa0-44d6-ad82-5f64a2543422">


우리는 해당 객체를 __"필요할 때만"__ 만들어서 구현할 수 있다. 이럴때 객체의 모든 클라이언트는 어떤 지연된 코드를 실행해야하는데 이를 위해서는 __코드 중복__ 을 초래할 수 있다.

__이를 해결할 수 있는 이상적인 방법__ <br>
✨ 위에서 이야기한 코드들 __객체의 클래스__ 에 직접 넣는다.

그러나, 클래스가 폐쇄된 타사의 라이브러리의 일부일수도 있기에 항상 가능한 방법은 아니다.

### 😀 해결책
프록시 패턴은 원래 서비스 객체와 같은 인터페이스로 새 프록시 클래스를 생성하라고 제안
<br>
그러면 프록시 객체를 원래 객체의 모든 클라이언트들에 전달하도록 앱을 업데이트할 수 있다.
<br>
클라이언트로부터 요청을 받으면 이 프록시는 실제 서비스 객체를 생성하고 모든 작업을 이 객체에게 위임

<img width="330" alt="image" src="https://github.com/spaaaams/boook/assets/51051548/f29904f2-cfab-4bb7-b2f3-71751207e58e">


이것들은 클래스의 메인 로직 __이전__ 이나 __이후__ 에 무언가를 실행해야하는 경우 해당 클래스를 변경하지 않고도 수행할 수 있도록 합니다.

✨ 즉, 프록시는 원래 클래스와 __같은 인터페이스는 구현__ 하므로 실제 서비스 객체를 기대하는 모든 클라이언트에게 전달

### 🗼 구조

<img width="306" alt="image" src="https://github.com/spaaaams/boook/assets/51051548/f7c82711-f4c8-45e0-8c65-22f49754cfa2">


__1.서비스 인터페이스__<br>
- 서비스의 인터페이스 선언
- 프록시가 서비스 객체로 위장하기 위해 이 인터페이스를 따라야한다.

__2.서비스__<br>
어떤 유용한 비즈니스 로직을 제공하는 클래스

__3.프록시__<br>
- 클래스에는 서비스 객체를 가리키는 참조 필드 존재
- 프록시가 요청의 처리를 완료하면 이후, 처리된 요청을 서비스 객체에 전달<br>
_요청의 처리 예시 : 초기화 지연 / 로깅 / 엑세스 제어 / 캐싱 등_<br>
- 프록시들은 서비스 객체의 전체 수명주기 관리

__4.클라이언트__ <br>
같은 인터페이스를 통해 서비스 및 프록시들과 함께 작동해야한다.<br>
그러면, 서비스 객체를 기대하는 모든 코드에 프록시를 전달할 수 있기 때문.

### 👾 프록시 패턴의 종류
#### 가상 프록시
가끔만 사용되는 __무거운 서비스 객체__ 가 __항상__ 가동되어있어 시스템자원을 낭비하는 경우

앱이 시작될 때 객체를 생성하는 대신, 객체 초기화를 실제로 __초기화가 필요한 시점까지 연기__ 할 수 있다.

#### 원격프록시
서비스 객체가 원격 서버에 있는 경우

이경우 프록시는 네트워크를 통해 클라이언트 요청을 전달하여 네트워크와의 작업의 모든 복잡한 세부사항을 처기
_(예: Google Docs)_
 

#### 보호프록시
특정 클라이언트들만 서비스 객체를 사용할 수 있도록 하는 경우에 사용할 수 있다.

클라이언트의 자격 증명이 어떤 정해진 기준과 일치하는 경우에만 서비스 객체에 요청을 전달할 수 있다.

#### 로깅 프록시
서비스 객체에 대한 요청들의 기록을 유지하려는 경우

프록시는 각 요청을 서비스에 전달하기 전에 로깅(기록)할 수 있다.

#### 캐싱 프록시
클라이언트 요청들의 결과를 캐시하고 이 캐시들의 수명 주기를 관리해야하는 경우

프록시는 항상 같은 결과를 생성하는 반복 요청들에 대해 캐싱 구현


### 💻 구현
CASE : 용량이 큰 이미지와 글이 같이 있는 문서를 화면에 띄워야함.<br>
텍스트는 용량이 작아서 빠르게 나타나지만 이미지는 용량이 크기 때문에 느리게 로딩되는 것을 확인할 수 있다.<br>
만약 이렇게 처리되지 않고 텍스트와 이미지 로딩이 모두 끝난 후 화면이 나온다면 사용자는 로딩이 끝날때까지 기다려야 한다.

따라서, 로딩이 먼저 끝난 텍스트를 먼저 나오게 하는 것이 좋다.<br>
이와 같은 방식을 가지려면 텍스트 처리용 프로세스, 이미지 처리용 프로세스를 별도로 운영하면 될 것이다.

```
// useImageLoader.js - 이미지 로딩을 위한 훅
import { useState, useEffect } from 'react';

const useImageLoader = (src) => {
    const [loaded, setLoaded] = useState(false);
    const [error, setError] = useState(null);

    useEffect(() => {
        const image = new Image();
        image.src = src;
        image.onload = () => setLoaded(true);
        image.onerror = (err) => setError(err);
    }, [src]);

    return { loaded, error };
};

export default useImageLoader;

// ProxyImage.js - 프록시 이미지를 나타내는 컴포넌트
import React from 'react';
import useImageLoader from './useImageLoader';

const ProxyImage = ({ src, alt }) => {
    const { loaded, error } = useImageLoader(src);

    if (error) return <div>Error loading image</div>;

    return (
        <div>
            {loaded ? (
                <img src={src} alt={alt} />
            ) : (
                <div>Loading image...</div>
            )}
        </div>
    );
};

export default ProxyImage;

// App.js - 메인 컴포넌트에서 텍스트와 이미지를 함께 로딩하는 모습을 구현
import React from 'react';
import ProxyImage from './ProxyImage';

const App = () => {
    return (
        <div>
            <div>
                <h1>텍스트 로딩 완료!</h1>
                <p>여기는 텍스트가 있는 부분입니다.</p>
            </div>
            <div>
                <ProxyImage src="path_to_your_image1.jpg" alt="Image 1" />
                <ProxyImage src="path_to_your_image2.jpg" alt="Image 2" />
            </div>
        </div>
    );
};

export default App;


```


### ✅ ❎ 장단점
__✅ 장점__ 

- 사이즈가 큰 객체가 __로딩되기 전에도 프록시를 통해 참조__ 를 할 수 있다.
- 실제 객체의 public, protected 메소드를 숨기고 인터페이스를 통해 노출시킬 수 있다.
- 로컬에 있지 않고 떨어져있는 객체를 사용할 수 있다.
- 원래 객체에 접근에 대해 사전처리를 할 수 있다.

__❎ 단점__ 

- 객체를 생성할 때 한 단계를 거치게 되므로, 빈번한 객체 생성이 필요한 경우 성능이 저하될 수 있다.
- 프록시 내부에서 객체 생성을 위해 스레드가 생성, 동기화가 구현되어야 하는 경우 성능이 저하될 수 있다.
- 로직이 난해해져 가독성이 떨어질 수 있다.
