# 🧩 플라이웨이트 패턴 (Flyweight Pattern)

`플라이웨이트 패턴`은 객체들이 **공통 상태를 공유**하여 **메모리 사용을 줄이고**, 더 많은 객체를 **효율적으로 관리**할 수 있게 하는 디자인 패턴입니다.

> **캐시** 또는 **Flyweight** 라고도 불립니다.

<br />

## ☹️ 문제 직면!

유저들이 맵을 돌아다니며 총을 쏘는 간단한 비디오 게임을 구현하고 있다고 가정해 봅시다.
<br />
폭발로 인한 방대한 양의 총알, 미사일, 파편들이 맵 전체를 날아다니는 전율 넘치는 경험을 선사하기 위해 사실적인 *입자 시스템*을 구현했습니다.

게임을 완성한 후 테스트를 해보니 특정 유저의 환경에서는 시작 후 몇 분만에 게임이 충돌했습니다.
<br />
디버그 로그를 살펴보니, 해당 유저의 컴퓨터 RAM이 충분하지 않아 게임이 충돌한 것이었습니다.

문제의 원인은 *입자 시스템*에 있었습니다.
<br />
각 총알, 미사일, 파편 등 모든 입자는 많은 데이터를 포함한 별도의 객체로 표시되었습니다.
<br />
플레이어 화면에 많은 입자가 생성될 때 RAM이 부족하여 프로그램이 충돌한 것입니다.

<p align="center">
  <img src="https://refactoring.guru/images/patterns/diagrams/flyweight/problem-ko.png?id=572f292324b5b3acee0d24f9b4e86814" alt="플라이웨이트 패턴 문제" width="660" />
</p>

<br />

## 🧐 해결책

`Particle 클래스`를 자세히 살펴보면 `color` 및 `sprite` 필드들이 다른 필드들보다 훨씬 더 많은 메모리를 사용한다는 것을 알 수 있습니다.
<br />
문제는 이 두 필드가 모든 입자에 걸쳐 거의 같은 데이터를 저장한다는 것입니다.
<br />
예를 들어, <u>모든 총알은 같은 색상과 스프라이트를 갖습니다.</u>

<p align="center">
  <img src="https://refactoring.guru/images/patterns/diagrams/flyweight/solution1-ko.png?id=8736baf093d68831d33835efd83f59f1" alt="플라이웨이트 패턴 해결책" width="640" />
</p>

`coords`, `vector`, `speed`와 같은 `Particle` 상태의 다른 부분들은 각 `Particle` 마다 **고유**하며, 이러한 필드들의 값은 시간이 지남에 따라 변경됩니다.
<br />
이 데이터는 `Particle`의 계속 변화하는 콘텍스트를 나타내지만, `color`, `sprite` 필드는 각 `Particle` 마다 일정하게 유지됩니다.

이러한 상수 데이터를 일반적으로 **고유한 상태**라고 하며, 객체 안에서만 살며 다른 객체들이 읽을 수는 있지만 변경할 수는 없습니다.
<br />
반면, 종종 다른 객체들에 의해 _외부에서_ 변경되는 객체의 나머지 상태를 **공유한 상태**라고 합니다.

`플라이웨이트 패턴`은 객체 내부에 공유한 상태의 저장을 중단하고, 대신 이 상태를 특정 메서드에 전달할 것을 제안합니다.
<br />
고유한 상태만 객체 내에 유지되므로 해당 고유한 상태는 콘텍스트가 다른 곳에서 재사용할 수 있습니다.
<br />
이러한 객체들은 공유한 상태보다 변형이 훨씬 적은 고유한 상태에서만 달라지므로 훨씬 더 적은 수의 객체만 있으면 됩니다.

<p align="center">
  <img src="https://refactoring.guru/images/patterns/diagrams/flyweight/solution3-ko.png?id=518a4d27e38553f19e02adf737daec12" alt="플라이웨이트 패턴 해결책" width="424" />
</p>

게임을 다시 살펴보면, `Particle 클래스`에서 **공유한 상태**를 추출함으로써 총알, 미사일, 파편의 세 가지 다른 객체만으로도 게임의 모든 Particle을 충분히 나타낼 수 있습니다.
<br />
**고유한 상태**만 저장하는 이러한 객체를 `플라이웨이트`라고 합니다.

`플라이웨이트 패턴`을 적용하면, <u>RAM 사용을 줄이고 더 많은 입자를 효율적으로 관리</u>할 수 있어 게임의 성능을 크게 개선할 수 있습니다.

### 공유한 상태 스토리지

일부 클래스가 이 상태를 여전히 저장해야 합니다.
<br />
대부분의 경우, 공유 상태는 패턴을 적용하기 전에 객체들을 집합시키는 컨테이너 객체로 이동됩니다.

게임에서 이 역할을 하는 것은 `particle` 필드에 모든 입자를 저장하는 주요 `Game` 객체입니다.
<br />
공유 상태를 이 클래스로 이동하려면 개별 입자의 좌표, 벡터, 속도를 저장할 여러 배열 필드를 생성해야 합니다.
<br />
또한, 입자를 나타내는 특정 `플라이웨이트`에 대한 참조를 저장할 다른 배열이 필요합니다.
<br />
이러한 배열들은 같은 인덱스를 사용하여 입자의 모든 데이터에 액세스할 수 있도록 동기화되어야 합니다.

<p align="center">
  <img src="https://refactoring.guru/images/patterns/diagrams/flyweight/solution2-ko.png?id=65b480543ba6c454157be874b8041b56" alt="플라이웨이트 패턴 해결책" width="640" />
</p>

더 나은 해결책은 플라이웨이트 객체에 대한 참조와 함께 공유된 상태를 저장할 별도의 콘텍스트 클래스를 만드는 것입니다.
<br />
이 접근 방식에서는 컨테이너 클래스에 단일 배열만 있으면 됩니다.

이런 콘텍스트 객체들이 많이 있어야 하지 않나요? 맞습니다.
<br />
그러나 이제 이 객체들은 훨씬 작습니다.
<br />
메모리를 많이 사용하는 필드들이 몇 개의 플라이웨이트 객체로 이동되었기 때문입니다.
<br />
이제 하나의 큰 플라이웨이트 객체를 수천 개의 작은 콘텍스트 객체들이 재사용할 수 있습니다.

### 플라이웨이트와 불변성

같은 플라이웨이트 객체가 여러 콘텍스트에서 사용되므로, 상태가 수정되지 않도록 해야 합니다.
<br />
상태는 생성자 매개변수를 통해 한 번만 초기화하고, setter나 public 필드를 노출하지 않습니다.

### 플라이웨이트 팩토리

플라이웨이트 객체를 효율적으로 관리하기 위해, 기존 객체를 재사용하거나 새 객체를 생성하는 팩토리 메서드를 생성합니다.
<br />
이 메서드는 클라이언트가 원하는 플라이웨이트의 고유한 상태를 받아 객체를 반환합니다.

<br />

## 🤓 구조

<p align="center">
  <img src="https://refactoring.guru/images/patterns/diagrams/flyweight/structure-indexed.png?id=aa490792baa26b04464dacbc1f4a19cd" alt="플라이웨이트 디자인 패턴 구조" width="630" />
</p>

- 플라이웨이트 클래스: 여러 객체들이 공유할 수 있는 원래 객체의 상태 일부를 포함합니다.
- 콘텍스트 클래스: 고유한 상태를 포함하며, 플라이웨이트 객체와 쌍을 이루어 원래 객체의 전체 상태를 나타냅니다.
- 플라이웨이트 팩토리: 기존 플라이웨이트 객체들을 관리하며, 클라이언트가 요청하는 고유한 상태에 맞는 객체를 반환합니다.

<br />

## 🤓 예시코드

플라이웨이트 패턴을 사용하여 캔버스에 수백만 개의 나무 객체들을 렌더링하는 예제입니다.

<p align="center">
  <img src="https://refactoring.guru/images/patterns/diagrams/flyweight/example.png?id=0818d078c1a79f373e96397f37b7ee06" alt="플라이웨이트 패턴 예시" width="540" />
</p>

이 패턴은 주요 Tree​(나무) 클래스에서 반복되는 고유한 상태를 추출하여 Tree­Type​(나무 종류) 플라이웨이트 클래스로 이동합니다.

같은 데이터를 여러 객체에 저장하는 대신 이제 몇 개의 플라이웨이트 객체들에 보관되고 콘텍스트 역할을 하는 적절한 Tree 객체들에 연결됩니다.
<br />
클라이언트 코드는 플라이웨이트 팩토리를 사용하여 새 Tree 객체들을 생성합니다.
<br />
이 팩토리는 올바른 객체를 검색하고 필요한 경우 재사용하는 작업의 복잡성을 캡슐화합니다.

```typescript
// TreeType 클래스는 트리의 상태 일부를 포함합니다. 많은 트리들이 공유하는 질감과 색상을 저장합니다.
class TreeType {
  constructor(
    public name: string,
    public color: string,
    public texture: string
  ) {}

  draw(canvas: HTMLCanvasElement, x: number, y: number): void {
    const context = canvas.getContext("2d");
    if (context) {
      context.fillStyle = this.color;
      context.fillRect(x, y, 10, 10); // 간단한 사각형으로 트리를 그립니다.
      context.font = "12px Arial";
      context.fillText(this.name, x, y - 5); // 트리 이름을 그립니다.
    }
  }
}

// TreeFactory 클래스는 기존 TreeType을 재사용하거나 새 객체를 생성합니다.
class TreeFactory {
  private static treeTypes: Map<string, TreeType> = new Map();

  static getTreeType(name: string, color: string, texture: string): TreeType {
    const key = `${name}-${color}-${texture}`;
    let type = this.treeTypes.get(key);
    if (!type) {
      type = new TreeType(name, color, texture);
      this.treeTypes.set(key, type);
    }
    return type;
  }
}

// Tree 클래스는 트리의 상태 중 공유되지 않는 부분을 포함합니다.
class Tree {
  constructor(public x: number, public y: number, public type: TreeType) {}

  draw(canvas: HTMLCanvasElement): void {
    this.type.draw(canvas, this.x, this.y);
  }
}

// Forest 클래스는 트리와 숲을 관리하는 역할을 합니다.
class Forest {
  private trees: Tree[] = [];

  plantTree(
    x: number,
    y: number,
    name: string,
    color: string,
    texture: string
  ): void {
    const type = TreeFactory.getTreeType(name, color, texture);
    const tree = new Tree(x, y, type);
    this.trees.push(tree);
  }

  draw(canvas: HTMLCanvasElement): void {
    for (const tree of this.trees) {
      tree.draw(canvas);
    }
  }
}

// 예제 사용법
const canvas = document.createElement("canvas");
canvas.width = 800;
canvas.height = 600;
document.body.appendChild(canvas);

const forest = new Forest();
forest.plantTree(100, 100, "Oak", "green", "rough");
forest.plantTree(150, 120, "Pine", "darkgreen", "smooth");
forest.plantTree(200, 80, "Birch", "white", "striped");
forest.draw(canvas);
```

보통의 `플라이웨이트 패턴`은 다음과 같은 경우에 사용합니다.

1. 앱이 수많은 유사 객체들을 생성해야 할 때
2. 이것이 대상 장치에서 사용할 수 있는 모든 RAM을 소모할 때
3. 이 객체들에 여러 중복 상태들이 포함되어 있으며, 이 상태들이 추출된 후 객체 간에 공유될 수 있을 때

> ⚠️ 플라이웨이트 패턴은 프로그램이 많은 수의 객체들을 지원해야 해서 사용할 수 있는 RAM을 거의 다 사용했을 때만 사용하세요.

<br />

## 🤓 장단점

⭕ 장점

- 메모리 사용량 절감
- 객체 생성 시간 감소
- 성능 개선

❌ 단점

- 코드 복잡도 증가
- 외부 상태를 관리해야 하는 부담
